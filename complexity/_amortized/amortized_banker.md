## Банковский метод

Даже в случае с операцией `push_back` пришлось сделать немало математических вычислений, чтобы получить точное значение $c_{\text{avg}}$. В более сложных структурах данных подобные вычисление могут быть непосильно трудными. Для решения этой проблемы Роберт Тарьян и пишет работу по амортизационному анализу, предлагая инструмент, позволяющий *оценивать сверху* среднюю сложность. Как мы знаем, реальные сложности операций в цепочке $c_i$ могут очень сильно колебаться, и если найти способ, как оценить все эти колебания, то можно будет говорить и об оценке общей суммарной сложности.

{% include onepar_element.html type="warning"
text="*Основной целью амортизационного анализа* является поиск разумной средней оценки $c'_i$ на временную сложность операции. Если сложить все эти оценки, то должна получиться оценка сверху на суммарную сложность всей цепочки операций."
%}

Изучим банковский метод. Предположим, что компьютер очень любит рубли и что за 1  &#8381; он готов выполнить константное  количество атомарных операций. (Почем сейчас рубль? В разных анализах можно уточнить, сколько именно операций, если это нужно.) Также представим себе, что у нас есть отдельный изначально пустой мешок, куда можно складывать и копить рубли. За каждую операцию мы будем начислять себе на руки определенное количество рублей - зарплату.

{% include onepar_element.html type="definition"
text="Количество начисляемых рублей перед выполнением операции в банковском методе называется ее *амортизированной сложностью (учетной стоимостью)*."
%}

Также у операции есть ее реальная временная сложность $c_i$. Столько рублей мы будем вынуждены платить за ее выполнение. *Наша цель показать, что все операции цепочки могут быть выполнены за указанные учетные стоимости $c'_i$.* Если нам дали больше денег, чем операция стоит на самом деле, то мы имеем возможность расплатиться за нее, а затем сложить оставшуюся валюту в мешок (либо вообще выкинуть :)). Если учетной стоимости недостаточно, чтобы выполнить некоторую дорогую операцию, то мы вынужденны пользоваться накоплениями и достать какое-то количество нехватающих денег из мешка. Необходимо показать, что денег в мешке хватает всегда, иначе анализ не сойдется. В этом методе нельзя брать кредиты, то есть просить еще денег из уже пустого мешка. 

Понятно, что если мы смогли доказать, что денег для оплаты цепочки операций достаточно, то суммарная фактическая временная сложность всех операций будет оценена сверху суммой всех амортизированный сложностей. 

На практике накопления удобно складывать не в мешок, а размещать прямо внутри структуры данных, на ее элементах, узлах. Здесь важно сделать замечание, что все эти деньги --- наша выдумка для науки, в коде никаких рублей нет и хранить их не нужно.

Проведем анализ той же цепочки `push_back` банковским методом. Так как мы целимся в амортизационную оценку $\mathcal{O}(1)$, то нам необходимо просить каждый раз одинаковое фиксированное количество рублей. Попросим за каждый `push_back` по 4 &#8381;. 

Чтобы показать, что при любом раскладе у нас хватит денег в запасе, необходимо сформулировать и доказать *инвариант* раскладки денег по структуре данных. Заметим, что следующие неравенства верны для любого момента времени:

$
\dfrac{\texttt{capacity}}{2} \leqslant \texttt{size} \leqslant \texttt{capacity}. 
$

Они следуют напрямую из устройства реаллокаций в процессе `push_back`: вектор действительно всегда заполнен хотя бы наполовину. Утвердим следующий инвариант: в правой половине вектора (от $1/2\, \texttt{capacity}$ до $\texttt{capacity}$) над каждым элементом лежит по 2 &#8381;. Проверим теперь, на каждый ли `push_back` нам хватит этих денег и сохраняется ли этот инвариант. Для этого рассмотрим два случая.

Пусть в процессе `push_back` реаллокация не потребовалась. Тогда нам выдают 4 &#8381;, 1 &#8381; мы тратим на непосредственное присваивание элемента в память вектора, 2 &#8381; положим над этим элементом, а 1 &#8381; выкинем. Инвариант не нарушен, денег хватило.

Теперь случай сложнее: случилась реаллокация. Нам снова дают те же самые 4 &#8381;. В этой ситуации 1 &#8381; мы потратим на выделение новой памяти под вектор.  Каждый элемент старой правой половины будет оплачивать по 1 &#8381; копирование соответствующего ему элемента левой половины, и по 1 &#8381; за копирование себя в новый вектор. Заметим, что все скопированные элементы теперь лежат в левой половине нового вектора и по нашему инварианту мы не должны беспокоиться о деньгах над ними. Добавим теперь элемент в новый вектор, потратив на это 1 &#8381; из зарплаты. Остались 2 &#8381;, которые мы кладем над этим новым элементом. Так как это единственный элемент в новой правой половине, инвариант не нарушен. Денег хватило.

Таким образом у нас сошелся анализ банковским методом операции `push_back`. Его амортизированная стоимость получилась равна 4, что составляет $\mathcal{O}(1)$. 

Сформулируем банковский метод по шагам:

* Ввести <<валюту>>. Сформулировать какие операции и сколько готова выполнять машина за 1 единицу валюты.
* Назначить амортизационные сложности каждой операции - попросить зарплату за каждую операцию.
* Сформулировать инвариант: где и сколько *гарантированно* лежат средства в любой момент времени.
* Для каждой операции четко прописать, какие деньги и куда тратить, как перекладывать. Показать, что инвариант не нарушается ни при каких условиях и что денег всегда хватает.




