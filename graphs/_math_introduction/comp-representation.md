## Внутреннее представление

Теперь, имея более или менее полноценное представление о математическом объекте граф, можно заняться и алгоритмами. Любой подобный разговор начинается с вопроса внутреннего представления в ЭВМ. Хранить графы в памяти можно совершенно по-разному; мы обсудим основные три способа, помечая для себя технические особенности.

Пусть множество $V=\\{0,\,1,\,2\,\ldots\\} \subset \mathbb{N}$. Таким образом, все вершины для нас - натуральные числа. Множество $E$ представляет из себя множество упорядоченных пар натуральных чисел.

Прежде всего, если не оговорено обратное, будем считать все графы направленными. Так поступить проще: почти все изучаемые нами алгоритмы предназначены именно для них. Если в задаче все-таки необходимо работать с неориентированным графом, в большинстве случаев мы можем свести его к ориентированному следующим образом:

$$ E\ni \{x,\, y\} \quad\Longrightarrow\quad (x,\,y) + (y,\, x) \in E,$$

то есть превращая ненаправленное ребро в две направленные в противоположные стороны дуги. Далее, скорее всего, будет прекрасно работать нужный нам алгоритм для ориентированного графа. Конечно, бывают случаи, когда так сделать нельзя, но это единичная отдельная история.

Часто, если встретились параллельные ребра (дуги), их можно склеивать в одно ребро (дугу) некоторым образом в зависимости от задачи (складывая веса, что-то помечая ...) Потому сейчас их тоже не рассматриваем.

Мы рассмотрим три основных способа внутреннего представления графа.

### Список ребер

Самая первая и банальная идея хранить граф в виде обычного списка (или вектора) ребер не является практичной, однако может использоваться в некоторых алгоритмах (вместе с другими структурами, как что-то вспомогательное). Технически список ребер может быть оформлен как 
```c++
  std::vector<std::pair<int, int>> edge_list(m);
```
Вместо `std::pair` может использоваться какая угодно собственная структура `Edge`.

Понятно, что особых преимуществ не имеет, так как представляет из себя обычый вектор (список), и чтобы найти в нем хоть что-то, придется пройти его весь. Память $\mathcal{O}(\|E\|)$.

### Матрица смежности 

{% include onepar_element.html type="definition" label="def_adj_mat"
text="*Матрицей смежности (adjacency matrix)* называется квадратная матрица  $A$ размера $\|V\|\times \|V\|$ для хранения графа. В элементе $a_{ij}$ (элемент на пересечении $i$-ой строки и $j$-го столбца) хранится некоторое специальное значение, которое кодирует информацию о ребре, инцидентному вершинам $i$ и $j$."
%}

```
КАРТИНКА
```

В качестве элементов часто выступают единички и нолики. Понятно, что это просто булевская пометка для каждой пары вершин: <<дуга есть>>, <<дуги нет>>.

На этой картинке видно, что есть дуга из $i$ в $j$, а, например, из вершины $i$ в $k$ дуги нет, как и из вершины $j$ в $i$. Отсюда очевидно следует, что *матрица смежности неориентированного графа симметрична относительно главной диагонали.*

Чтобы изучить, какие ребра выходят из данной вершины $i$, достаточно совершить обход этой матрицы по $i$-ой строке.

<div class="question">Что означают элементы на главной диагонали матрицы смежности? Всегда ли там стоят нули?</div>

<div class="question">Как по матрице смежности определить стоки? истоки?</div>

В качестве $a_{ij}$ могут выступать и веса ребер, либо какие-то другие специальные значения, в зависимости от задачи. Также можно заниматься и теорией матриц, и искать соответствия между математическими свойствами матрицы и графом (занимается [спектральная теория графов](https://ru.wikipedia.org/?curid=5305046&oldid=124633594){:target="_blank"}).

Приятными плюсами является простота использования и скорость доступа к информации о ребре. Очевидным сокрушительным недостатком является $\mathcal{O}(\|V\|^2)$ памяти. Достаточно глупо отводить столько памяти только под хранение, особенно в случае, когда граф *разреженный (sparse)*: вершин много, а связей мало. Таких достаточно много. Типичный пример - граф сети Интернет (вершины - веб-страницы, связи - наличие ссылки внутри одной страницы на другую). Сейчас в Интернете уже есть как минимум 4,58 млрд веб-страниц, а это уже $\approx 1,9\cdot 10^7$ ТиБ (тебибайт).

### Список смежности

Матрица смежности исходит из идеи помнить информацию о всевозможных вариантах расстановки ребер в графе, в результате чего в памяти может получиться большое пространство из нулей. Понятным желанием будет вычеркнуть эти нули. Часто при построении алгоритма интуитивно-понятным кажется действие просмотра <<соседей>> вершины: мы как бы постоянно отталкиваемся от какой-то вершины и изучаем, что находится непосредственно около нас. Такая операция называется *Fetch*: она сопоставляет вершине $v$ список из всевозможных $\{(v, w)\}\in E$, то есть просматривает <<соседей>>. Поэтому естественной будет идея запомнить всех этих соседей.

{% include onepar_element.html type="definition" label="def_adj_list"
text="*Список смежности (adjacency list)* представляет из себя коллекцию (список, вектор, массив) из списков вершин. Каждой вершине $i$ сопоставляется список из вершин $j$, таких что $(i,\, j)\in E$."
%}

Де-факто в С++ (хоть это и не совсем хорошо) часто оформляют список смежности в виде 

```c++
  std::vector<std::vector<int>> adjacency_list(n);
```
Этот код создает вектор из $n$ пустых векторов (где $\|V\|=n$), которые потом наполняются в цикле командой вида 
```c++
  adjacency_list[i].push_back(j);
```
в момент чтения данных. Например, список смежности для 

```
КАРТИНКА
```
будет вектором вида $\\{\\{\\},\;\\{\\},\; \\{\\}\\}$. Это простая, с точки зрения написания кода, реализация, однако она может провисать из-за все-таки сложной динамической структуры данных `std::vector`. В идеале элементы внешнего вектора должны быть именно списками.

<div class="question">Как будет выглядит список смежности для этого же графа, если его ребра направить в противоположную сторону?</div>

Такое решение потребует порядка $\mathcal{O}(\|V\|+\|E\|)$ памяти. Если граф разрежен, то можно считать, что $\mathcal{O}(\|V\|)$. В случае графа сети Интернет получаем прикидку $\approx 4,3$ ГиБ (гибибайта), что уже влезет на хорошую флешку.

#### Дополнительно: улучшенный список смежности

Если решается offline задача, то есть граф статический и известен заранее, то можно сделать еще более аккуратную реализацию. Идея заключается в том, что мы не будем делать вложенных структур данных, два вектора: вектор вершин `vertices` и вектор ребер `edges`. 

```
КАРТИНКА
```

При этом ребра, идущие из одной вершины, хранятся в массиве `edges` рядом. В элементе `vertices[i]` мы храним указатель на начало <<куска>> ребер в `edges`, которые идут из вершины с номером $i$. Таким образом, чтобы перебрать все ребра из данной вершины, необходимо перейти по указателю с номером нужной вершины и просто начать перечислять подряд ребра. Понятно, что указатель на начало следующего <<куска>> `vertices[i+1]`, для следующей вершины, является одновременно и концом участка текущей вершины $i$. Внимательный читатель здесь укажет, что у последней вершины нет указателя конца участка в массиве ребер. Это действительно так. Можно использовать `if`-конструкции в коде для этой ситуации, либо сделать sentinel (вершину с номером max + 1) вершину в конце массива `vertices` и присвоить ей указатель `end` массива `edges`; в таком случае обработка вершины с максимальным номером не является особой ситуацией.

Всего этого можно добиться, отсортировав ребра графа по первой вершине. Затем, проходя этот массив, запоминать моменты перехода на другую первую вершину в массив вершин `vertices`.

Такой подход, очевидно, также укладывается в $\mathcal{O}(\|V\|+\|E\|)$ памяти. Однако он не содержит лишнего и хорошо дружит с кэшем (Cache friendly). Процессор всегда подгружает память из RAM кэш-линиями (см. [habr - логическая организация кэш-памяти процессора](https://habr.com/ru/post/179647/){:target="_blank"}), подгружая не одиночные байты, а куски, в надежде, что в ближайшее время будут обращения к чему-то соседнему. Храня граф так, мы очень удачно, с точки зрения процессора, располагаем в памяти перечисляемые ребра.

