Когда как следует изучен граф как объект и разработаны способы его хранения в ЭВМ, правильно переходить к обработке этой новой для нас структуры данных. Ясно, что перечислять вершины просто так или беспорядочно просматривать ребра может быть малополезным занятием. Необходима логика, учет связей, топологии графа. 

Теперь мы должны исходить из того, что граф уже создан и подан нам на вход, на нем необходимо решить некоторую задачу. Для нас он подобен черной неразведанной части местности в играх-стратегиях реального времени. Необходимо раскрыть эту местность. Существуют две главные стратегии обхода графов, из которых рождаются большинство уже сложных и универсальных алгоритмов, и различаются эти стратегии по быстроте изменения того или иного <<измерения>>: обход в глубину (англ. **D**epth-**F**irst **S**earch) и обход в ширину (англ. **B**readth-**F**irst **S**earch). Нечто похожее происходит при обходе матрицы по строкам, когда быстрее меняется измерение-столбец $j$, и обход по столбцам, когда быстро меняется измерение-строка $i$.

## Алгоритм обхода в глубину

Начнем изучение алгоритмов обхода с DFS. Силу этого алгоритма частно недооценивают: он решает сразу просто невообразимое количество задач. Потому DFS разберем максимально подробно. Сразу сформулируем алгоритм, затем попробуем понять его работу <<на словах>> и на примерах, и наконец строго докажем корректность его работы. Итак, пусть нам дан граф $G=(V,E)$. Заранее заготовим три цвета $\\{ {\color{cyan}\texttt{White}}, {\color{grey}\texttt{Grey}}, \texttt{Black}\\}$. Положим сперва, что все вершины белые.

{% include pseudo_code.html head='procedure dfs($v$: vertex)'
code='color[$v$] = $\texttt{Grey}$
for $\forall w: (v, w)\in E$:
    if color[$w$] == $\texttt{White}$
        dfs($w$)
color[$v$] = $\texttt{Black}$'%} 

Заметим, что алгоритм корректен в том смысле, что он может <<посетить>> вершину _только единожды_, и обязательно из нее выходит, пометив ее черной, когда заканчивается цикл перебора потомков. Значит, алгоритм не бесконечен, даже если в графе есть замкнутые пути (циклы).

Важно заметить, что в процессе работы алгоритма _вершины могут только темнеть_. Также из кода непосредственно следует, что после завершения работы алгоритма вершины графа могут быть только двух цветов: белые и черные. Сформулируем теперь <<роли>> наших цветов: 

* Белый цвет $\color{cyan} \texttt{White}$ означает, что вершина не была обработана в процессе $\texttt{dfs($v$)}$.
* Серый цвет $\color{grey} \texttt{Grey}$ означает, что вершина сейчас находится в стадии обработки рекурсивной функции $\texttt{dfs($v$)}$. Путь из серых вершин лежит на стеке, потому его возможная длина ограничена максимальной глубиной рекурсии. Но обычно проблем тут не возникает.
* Черный цвет $\texttt{Black}$ вершины означает, что функция $\texttt{dfs($v$)}$ закончила ее обработку, а следовательно, и обработку ее потомков. Очевидно, самой последней почернеет вершина $v$, из которой непосредственно был запущен поиск в глубину.

Запустим алгоритм $\texttt{dfs($s$)}$ из некоторой стартовой вершины $s$. 

     ПРИМЕР, плагин

Интуитивно понятно, что алгоритм стремиться <<дотянуться туда>>, куда он только может это сделать из вершины $s$. Таким образом, после работы алгоритма черными окажутся те вершины, до которых существует некоторый путь из $s$. То есть решается задача достижимости.

Для строгого доказательства корректности алгоритма а также для более ясного понимания принципа его работы необходимо рассмотреть следующую важнейшую лемму.

{% include onepar_element.html 
type="lemma" label="whitepath" name="О белом пути"
text='Пусть в некоторый момент произошел вызов $\texttt{dfs($v$)}$ (это не обязательно самый первый вызов $\texttt{dfs($s$)}$). Тогда множества тех вершин, обработка которых произойдет в процессе $\texttt{dfs($v$)}$ и множество тех вершин, до которых есть путь из $v$ только по белым вершинам, совпадают. 
Иными словами $\\{ w \,\|\, \texttt{dfs($w$)} \text{ happens during } \texttt{dfs($v$)} \\} = \\{ w \,\|\, \exists\, \text{white-path from $v$ to $w$} \\}$.'
proof='Рассмотрим произвольную белую вершину $w$. В одну сторону доказательство очевидно. Если белого пути из $v$ в $w$ не существует, то дойти до вершины $w$ просто не возможно, это следует из кода (алгоритм ходит только по белым вершинам). '
%}

