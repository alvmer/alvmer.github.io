 <!DOCTYPE html>
<html lang="ru">
  <head>
<!--    -->

  <meta charset="utf-8">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png">
  <link rel="manifest" href="/assets/favicons/site.webmanifest">
  <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#52796f">
  <link rel="shortcut icon" href="/assets/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/favicons/browserconfig.xml">
  <meta name="theme-color" content="#52796F">


  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Теория графов | Алексей Мерзляков</title>

  <meta name="description" content="Учим терминологию, рассматриваем базовые математические задачи, изучаем внутреннее представление.">
  <meta name="twitter:card" content="summary" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="http://localhost:4000/graphs/math-introduction.html" />
  <meta property="og:title" content="Теория графов | Алексей Мерзляков" />
  <meta property="og:description" content="Учим терминологию, рассматриваем базовые математические задачи, изучаем внутреннее представление." />
<!--   <meta property="og:image" content="https://www.markdownguide.org/assets/images/markdown-guide-og.jpg" /> -->

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">

  <link rel="stylesheet" type="text/css" href="/assets/css/font_faces.css">
  <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css">

  <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
  <link rel="stylesheet" href="/assets/css/bootstrap-toc.min.css">
  <link rel="stylesheet" href="/assets/css/docsearch.min.css">


  
  <link href="/assets/css/page.css" rel="stylesheet">
  

  <link rel="canonical" href="http://localhost:4000/graphs/math-introduction.html">

  <script src="/assets/javascript/jquery-3.5.1.slim.min.js"></script>
  <script async src="/assets/javascript/bootstrap.bundle.min.js"></script>
  <script async src="/assets/javascript/bootstrap-toc.min.js"></script>
  <script defer src="/assets/javascript/solid.min.js"></script>
  <!-- <script defer src="/assets/javascript/fontawesome.min.js"></script> -->
  <script async src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>

  <script src="https://kit.fontawesome.com/25675da278.js" crossorigin="anonymous"></script>

  <script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(','\\)']]
    }
  };
</script>

  <script>
    $(function () {
      $('[data-toggle="tooltip"]').tooltip()
    });
  </script>

  <style>
    .MathJax, .MathJax_Display  {
      /*text-align: center !important;*/
      font-size:  19px !important;
    }
  </style>
</head>

  <body data-spy="scroll" data-target="#toc">
    <nav class="navbar navbar-expand-lg navbar-dark mdg-nav">
  <div class="container">
    <a class="navbar-brand" href="/" style="margin-top: 0px; margin-bottom: 0px">
      <img src="/assets/images/amlogo-white.svg" height="37" width="37" class="d-inline-block align-top" alt="Alexey Merzlyakov" style="padding-right: 5px">
      Теория графов | Алексей Мерзляков 
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNavAltMarkup" style="margin-top: 2px">
      
      <!-- навигация для графов -->
      <div class="navbar-nav">
        <a class="nav-item nav-link active" href="/graphs/math-introduction.html">Введение</a>
        <a class="nav-item nav-link " href="/graphs/dfs.html">DFS</a>
        <a class="nav-item nav-link " href="/graphs/bfs.html">BFS</a>
        <a class="nav-item nav-link " href="/graphs/paths.html">Пути</a>
        <a class="nav-item nav-link " href="/graphs/hard.html">Сложное</a>
        <a class="nav-item nav-link " href="/graphs/flows.html">Потоки</a>
      </div>
      
    </div>
   <!--  <form class="form-inline d-none d-lg-inline-block mt-2 mt-md-0">
      <input type="text" class="form-control" id="search-input" placeholder="Search" style="margin-top:0">
    </form> -->
  </div>
</nav>

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
      <div class="container">
        <h1 class="no-anchor" data-toc-skip>Введение в теорию графов</h1>
        <p>Учим терминологию, рассматриваем базовые математические задачи, изучаем внутреннее представление.</p>
      </div>
    </div>
    <div class="container">
      <div class="row row-offcanvas row-offcanvas-right">
        <div class="col-xs-12 col-sm-12 col-md-9">
          <h2 id="что-ожидать-от-курса">Что ожидать от курса?</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Материал в работе...
</code></pre></div></div>

<h2 id="понятие-графа">Понятие графа</h2>

<p>Нередко начинающим математикам предлагают именно теорию графов в качестве одной из первых изучаемых дисциплин. Этот раздел дискретной математики, очевидно, обладает высокой наглядностью и явным прикладным характером. Однако в нем есть и абстрактные детали, есть высокая наука, где возникают задачи, которые даже до сих пор не решены.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Примеры нерешенных задач в выпадающем блоке...
</code></pre></div></div>

<p>Считается, что в 1736 году Леонард Эйлер первым применил идеи теории графов, несмотря на то, что в своих текстах явно не использовал понятие <em>граф</em>.  Он изучал проблему о кенигсбергских мостах, которой мы обязательно еще коснемся в рамках курса.</p>

<h3 id="главные-определения">Главные определения</h3>

<p>Обычно графы возникают тогда, когда в задаче есть набор каких-то элементов и необходимо учитывать какие-то связи между ними. Да, звучит очень широко, но в этом и есть вся сила теории графов. Можем рассмотреть города и дороги между ними, компьютеры и их связи в сетях, людей и знакомства или отношения друг другу, атомы и связи между ними в молекуле, и т.д. Можно привести и менее очевидные примеры: клетки лабиринта для робота, каждая связывается с теми, которые доступны для робота; символы строки и доступные преобразования для каждой и т.д. Таким образом,теория графов может возникать и в удивительных экзотических ситуациях, когда по задаче это совершенно не очевидно.</p>

<p>Рассмотрим формальные определения.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>

  Пусть $V$ - произвольное непустое множество. <em>Графом</em> $G = (V, E)$ назовем совокупность двух множеств $V$ и $E$. Множество $V$ при этом называется множеством <em>вершин</em> (точек, узлов).

   <a name="graph"></a> 
  <br />
  
</div>

<p>Заметим, что на множество $V$ вообще никаких ограничений не накладывается: оно может быть чем угодно, только не может быть пустым (а то не интересно). Может быть конечным, может бесконечным. Но мы будем изучать конечные графы.</p>

<p>Определение, данное выше, естественно, не полное. Обычно в задачах необходимы два типа графов: неориентированные и ориентированные (это разные объекты!), в зависимости от того, важна ли в задаче направленность ранее упомянутых «связей». Определения этих двух понятий зависят от определения множества $E$.</p>

<p>Итак, пусть $G=(V, E)$, $V\ne\varnothing$.</p>

<div class="container">
  <div class="row">
    <div class="col">
      <h4>Неориентированный граф</h4>
      $$E = \text\{ \\{ \{v_1, v_2 \} \,|\, v_1\ne v_2;\, v_1,\,v_2 \in V \} \\}$$
      Получается, элемент множества $E$ представляет из себя множество из двух элементов $V$. Так мы обозначаем "связь". <br />
        <ul>
            <li> Элемент $e\in E$ называется <em>ребром</em> (линией).</li>
            <li> Вершины $v_1$ и $v_2$ называются <em>концами</em> ребра $e=\text\{\\{v_1, v_2\}\\}$. При этом ребро $e$ <em>инцидентно</em> вершинам $v_1$ и $v_2$.</li>
            <li>Вершины $v_1$ и $v_2$ называются <em>смежными</em> или <em>соседними</em>, если $\text\{\\{v_1, v_2\}\\}\in E$, то есть существует инцидентное им ребро.</li>
            <li><em>Смежными ребрами</em> ($\text\{\\{v, v_1\}\\}$ и $\text\{\\{v, v_2\}\\}$) называются ребра, инцидентные одной вершине.</li>
            <li><em>Степенью</em> $d(v)$ вершины $v$ называют количество инцидентных ей ребер.</li>
            <li>Вершина $v$ называется <em>изолированной</em>, если $d(v)=0$. Называется <em>висячей (листом)</em>, если $d(v)=1$.</li>
        </ul>
    </div>
    <div class="col">
      <h4>Ориентированный граф</h4>
      $$E = \text\{ \\{ (v, w) \,|\, v\ne w;\, v,\,w \in V \} \\}\subset V\times V$$
      Получается, элемент множества $E$ представляет из себя множество <em>упорядоченных пар</em> элементов $V$. Так мы обозначаем <q>направленную связь</q>, так как нам важно отличать концы друг от друга: где начало, а где конец. <br />
        <ul>
            <li> Элемент $e\in E$ называется <em>направленным ребром, дугой, стрелкой</em> (или просто ребром, если понятно, о каком графе речь).</li>
            <li> Вершина $v$ называется <em>началом</em>, а вершина $w$ называется <em>концом</em> дуги $e=(v, w)$. При этом дуга $e$ <em>инцидентна</em> вершинам $v$ и $w$. Вершина $v$ называется <em>предком</em> вершины $w$.</li>
            <li>Ребро $(w, v)$ называется <em>обратным</em> ребру $(v, w)$.</li>
            <li><em>Степенью</em> $d(v)$ вершины $v$ называют количество инцидентных ей ребер. Определяют также <em>полустепень исхода</em> $d^{\text{out}} (v) = \\| \text\{\\{(v,w)\in E \}\\} \\|$ из вершины $v$, и <em>полустепень входа</em> $d^{\text{in}}(w) = \\| \text\{\\{(v,w)\in E \}\\} \\|$ в вершину $w$.</li>
            <li>Вершину $v$ называют <em>истоком</em>, если $d^{\text{in}}(v) = 0$, и называют <em>стоком</em>, если $d^{\text{out}}(v) = 0$. Вершину называют <em>изолированной</em>, если $d(v) = 0$.</li>
        </ul>
        <br />
        Заметим, что $\forall v\in V\colon d^{\text{in}} (v)
        +d^{\text{out}} (v) = d (v)$.
    </div>
  </div>
</div>
<p><br />
<em>Элементами графа</em> $G=(V, E)$ называют элементы множества $V \cup E$. <em>Порядком</em> этого графа называют количество вершин в нем $|V|$, а <em>размером</em> — количество ребер $|E|$. Часто в анализе алгоритмов возникает величина, зависящая от их суммы $|V|+|E|$.</p>

<p>Обратите внимание, что вверху было введено понятие инцидентности. Инцидентность используется для связи ребер и вершин, но никогда не применяется по отношению только двух вершин.</p>

<div class="alert alert-remark">
  <img class="alert-icon" src="/assets/images/icons/text.png" alt="icon" /><div class="alert-name">Замечание</div>

  <em>Терминология теории графов не является однозначной.</em> Разные авторы имеют в виду то одно, то другое, потому всегда сначала вводят свои определения. Путь, который мы выбрали, на взгляд автора, является наиболее удачным, так как объединяет в себе лучшее из разных трактовок, определения обладают общностью.

  
  <br />
  
</div>

<h3 id="уродства-кратные-рёбра-и-петли">Уродства: кратные рёбра и петли</h3>

<p>В мире графов тоже случаются неприятные вещи, причем часто неприятные во всех смыслах: с точки зрения описания на математическом языке, так и с точки зрения представления в ЭВМ; для того, чтобы учесть их в алгоритмах, нередко приходится заморочиться. Пожалуйста, вашему вниманию предлагаются следующие определения.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>

  <em>Кратными ребрами</em> называются ребра, имеющие одинаковые концы (совпадают начала и концы для ориентированного графа). <em>Петлей</em> называется ребро, концевые вершины которого совпадают (совпадают начало и конец для ориентированного графа).

   <a name="loopedges"></a> 
  <br />
  
</div>

<p><img src="/assets/images/graphs/naruto-clone.gif" alt="naruto" style="display:  block;margin-left:auto;margin-right:auto;width:50%;" /></p>

<p>Чтобы разрешить петли в неориентированном графе, нужно заявить, что множество $e$ (ребро) является мультимножеством из двух элементов. Тогда допустима запись $e = \{ v, v \}$ — петля. По понятным причинам снимается ограничение $v_1\ne v_2$ в определении.</p>

<p>Заметим, что в определении ориентированного графа достаточно лишь отменить требование $v\ne w$. В упорядоченной паре первый и второй элементы могут совпадать по определению.</p>

<p>Чтобы разрешить в графе кратные ребра, достаточно сказать, что само множетсво всех ребер (или дуг) $E$ является мультимножеством.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>
  Граф, в котором
  <ul>
    <li>отсутствуют кратные ребра и петли называется <em>простым</em>;</li>
    <li>есть кратные ребра называется <em>мультиграфом</em>;</li>
    <li>есть петли называется <em>псевдографом</em>.</li>
  </ul>
  Да, бывает <em>псевдомультиграф</em>.
</div>

<h2 id="лемма-о-рукопожатиях-и-прочее">Лемма о рукопожатиях и прочее</h2>

<h2 id="внутреннее-представление">Внутреннее представление</h2>

<p>Теперь, имея более или менее полноценное представление о математическом объекте граф, можно заняться и алгоритмами. Любой подобный разговор начинается с вопроса внутреннего представления в ЭВМ. Хранить графы в памяти можно совершенно по-разному; мы обсудим основные три способа, помечая для себя технические особенности.</p>

<p>Пусть множество $V=\{0,\,1,\,2\,\ldots\} \subset \mathbb{N}$. Таким образом, все вершины для нас - натуральные числа. Множество $E$ представляет из себя множество упорядоченных пар натуральных чисел.</p>

<p>Прежде всего, если не оговорено обратное, будем считать все графы направленными. Так поступить проще: почти все изучаемые нами алгоритмы предназначены именно для них. Если в задаче все-таки необходимо работать с неориентированным графом, в большинстве случаев мы можем свести его к ориентированному следующим образом:</p>

\[E\ni \{x,\, y\} \quad\Longrightarrow\quad (x,\,y) + (y,\, x) \in E,\]

<p>то есть превращая ненаправленное ребро в две направленные в противоположные стороны дуги. Далее, скорее всего, будет прекрасно работать нужный нам алгоритм для ориентированного графа. Конечно, бывают случаи, когда так сделать нельзя, но это единичная отдельная история.</p>

<p>Часто, если встретились параллельные ребра (дуги), их можно склеивать в одно ребро (дугу) некоторым образом в зависимости от задачи (складывая веса, что-то помечая …) Потому сейчас их тоже не рассматриваем.</p>

<p>Мы рассмотрим три основных способа внутреннего представления графа.</p>

<h3 id="список-ребер">Список ребер</h3>

<p>Самая первая и банальная идея хранить граф в виде обычного списка (или вектора) ребер не является практичной, однако может использоваться в некоторых алгоритмах (вместе с другими структурами, как что-то вспомогательное). Технически список ребер может быть оформлен как</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edge_list</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</code></pre></div></div>
<p>Вместо <code class="language-plaintext highlighter-rouge">std::pair</code> может использоваться какая угодно собственная структура <code class="language-plaintext highlighter-rouge">Edge</code>.</p>

<p>Понятно, что особых преимуществ не имеет, так как представляет из себя обычый вектор (список), и чтобы найти в нем хоть что-то, придется пройти его весь. Память $\mathcal{O}(|E|)$.</p>

<h3 id="матрица-смежности">Матрица смежности</h3>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>

  <em>Матрицей смежности (adjacency matrix)</em> называется квадратная матрица  $A$ размера $|V|\times |V|$ для хранения графа. В элементе $a_{ij}$ (элемент на пересечении $i$-ой строки и $j$-го столбца) хранится некоторое специальное значение, которое кодирует информацию о ребре, инцидентному вершинам $i$ и $j$.

   <a name="def_adj_mat"></a> 
  <br />
  
</div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>КАРТИНКА
</code></pre></div></div>

<p>В качестве элементов часто выступают единички и нолики. Понятно, что это просто булевская пометка для каждой пары вершин: «дуга есть», «дуги нет».</p>

<p>На этой картинке видно, что есть дуга из $i$ в $j$, а, например, из вершины $i$ в $k$ дуги нет, как и из вершины $j$ в $i$. Отсюда очевидно следует, что <em>матрица смежности неориентированного графа симметрична относительно главной диагонали.</em></p>

<p>Чтобы изучить, какие ребра выходят из данной вершины $i$, достаточно совершить обход этой матрицы по $i$-ой строке.</p>

<div class="question">Что означают элементы на главной диагонали матрицы смежности? Всегда ли там стоят нули?</div>

<div class="question">Как по матрице смежности определить стоки? истоки?</div>

<p>В качестве $a_{ij}$ могут выступать и веса ребер, либо какие-то другие специальные значения, в зависимости от задачи. Также можно заниматься и теорией матриц, и искать соответствия между математическими свойствами матрицы и графом (занимается <a href="https://ru.wikipedia.org/?curid=5305046&amp;oldid=124633594" target="_blank">спектральная теория графов</a>).</p>

<p>Приятными плюсами является простота использования и скорость доступа к информации о ребре. Очевидным сокрушительным недостатком является $\mathcal{O}(|V|^2)$ памяти. Достаточно глупо отводить столько памяти только под хранение, особенно в случае, когда граф <em>разреженный (sparse)</em>: вершин много, а связей мало. Таких достаточно много. Типичный пример - граф сети Интернет (вершины - веб-страницы, связи - наличие ссылки внутри одной страницы на другую). Сейчас в Интернете уже есть как минимум 4,58 млрд веб-страниц, а это уже $\approx 1,9\cdot 10^7$ ТиБ (тебибайт).</p>

<h3 id="список-смежности">Список смежности</h3>

<p>Матрица смежности исходит из идеи помнить информацию о всевозможных вариантах расстановки ребер в графе, в результате чего в памяти может получиться большое пространство из нулей. Понятным желанием будет вычеркнуть эти нули. Часто при построении алгоритма интуитивно-понятным кажется действие просмотра «соседей» вершины: мы как бы постоянно отталкиваемся от какой-то вершины и изучаем, что находится непосредственно около нас. Такая операция называется <em>Fetch</em>: она сопоставляет вершине $v$ список из всевозможных ${(v, w)}\in E$, то есть просматривает «соседей». Поэтому естественной будет идея запомнить всех этих соседей.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>

  <em>Список смежности (adjacency list)</em> представляет из себя коллекцию (список, вектор, массив) из списков вершин. Каждой вершине $i$ сопоставляется список из вершин $j$, таких что $(i,\, j)\in E$.

   <a name="def_adj_list"></a> 
  <br />
  
</div>

<p>Де-факто в С++ (хоть это и не совсем хорошо) часто оформляют список смежности в виде</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adjacency_list</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>
<p>Этот код создает вектор из $n$ пустых векторов (где $|V|=n$), которые потом наполняются в цикле командой вида</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">adjacency_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</code></pre></div></div>
<p>в момент чтения данных. Например, список смежности для</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>КАРТИНКА
</code></pre></div></div>
<p>будет вектором вида $\{\{\},\;\{\},\; \{\}\}$. Это простая, с точки зрения написания кода, реализация, однако она может провисать из-за все-таки сложной динамической структуры данных <code class="language-plaintext highlighter-rouge">std::vector</code>. В идеале элементы внешнего вектора должны быть именно списками.</p>

<div class="question">Как будет выглядит список смежности для этого же графа, если его ребра направить в противоположную сторону?</div>

<p>Такое решение потребует порядка $\mathcal{O}(|V|+|E|)$ памяти. Если граф разрежен, то можно считать, что $\mathcal{O}(|V|)$. В случае графа сети Интернет получаем прикидку $\approx 4,3$ ГиБ (гибибайта), что уже влезет на хорошую флешку.</p>

<h4 id="дополнительно-улучшенный-список-смежности">Дополнительно: улучшенный список смежности</h4>

<p>Если решается offline задача, то есть граф статический и известен заранее, то можно сделать еще более аккуратную реализацию. Идея заключается в том, что мы не будем делать вложенных структур данных, два вектора: вектор вершин <code class="language-plaintext highlighter-rouge">vertices</code> и вектор ребер <code class="language-plaintext highlighter-rouge">edges</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>КАРТИНКА
</code></pre></div></div>

<p>При этом ребра, идущие из одной вершины, хранятся в массиве <code class="language-plaintext highlighter-rouge">edges</code> рядом. В элементе <code class="language-plaintext highlighter-rouge">vertices[i]</code> мы храним указатель на начало «куска» ребер в <code class="language-plaintext highlighter-rouge">edges</code>, которые идут из вершины с номером $i$. Таким образом, чтобы перебрать все ребра из данной вершины, необходимо перейти по указателю с номером нужной вершины и просто начать перечислять подряд ребра. Понятно, что указатель на начало следующего «куска» <code class="language-plaintext highlighter-rouge">vertices[i+1]</code>, для следующей вершины, является одновременно и концом участка текущей вершины $i$. Внимательный читатель здесь укажет, что у последней вершины нет указателя конца участка в массиве ребер. Это действительно так. Можно использовать <code class="language-plaintext highlighter-rouge">if</code>-конструкции в коде для этой ситуации, либо сделать sentinel (вершину с номером max + 1) вершину в конце массива <code class="language-plaintext highlighter-rouge">vertices</code> и присвоить ей указатель <code class="language-plaintext highlighter-rouge">end</code> массива <code class="language-plaintext highlighter-rouge">edges</code>; в таком случае обработка вершины с максимальным номером не является особой ситуацией.</p>

<p>Всего этого можно добиться, отсортировав ребра графа по первой вершине. Затем, проходя этот массив, запоминать моменты перехода на другую первую вершину в массив вершин <code class="language-plaintext highlighter-rouge">vertices</code>.</p>

<p>Такой подход, очевидно, также укладывается в $\mathcal{O}(|V|+|E|)$ памяти. Однако он не содержит лишнего и хорошо дружит с кэшем (Cache friendly). Процессор всегда подгружает память из RAM кэш-линиями (см. <a href="https://habr.com/ru/post/179647/" target="_blank">habr - логическая организация кэш-памяти процессора</a>), подгружая не одиночные байты, а куски, в надежде, что в ближайшее время будут обращения к чему-то соседнему. Храня граф так, мы очень удачно, с точки зрения процессора, располагаем в памяти перечисляемые ребра.</p>


        </div>
        <div class="col-md-3 d-none d-md-block" id="sidebar">
          <nav id="toc" data-toggle="toc" class="sticky-top" style="z-index:1"></nav>
          
        </div>
      </div>
    </div>
    <footer class="site-footer">
  <div class="container">
    <!-- <p style="font-size: 14px; font-weight: 600"><a href="/about/">About</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="/contact/">Contact</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://github.com/mattcone/markdown-guide">GitHub</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="/api/v1/">API</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="/privacy-policy/">Privacy Policy</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="/terms-and-conditions/">Terms and Conditions</a></p>
    <p style="margin-top: 15px; font-size: 14px;">&#169; 2023. A <a href="https://www.mattcone.com">Alexey Merzlyakov</a> project. <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Made with 🌶️ in <a href="https://www.newmexico.org/">New Mexico</a>.</p> -->
  </div>
</footer>
<script type="text/javascript" src="/assets/javascript/anchor.min.js"></script>
<script>
  anchors.options = {
  placement: 'right',
  };
  anchors.add('h1, h2, h3, h4, h5').remove('.no-anchor');
</script>

<!-- for search -->
<script src="/assets/javascript/docsearch.min.js"></script>
<script>
docsearch({
container: '#docsearch',
appId: 'G2ZRR9A979',
apiKey: 'f522befe6142f2279344e025a79539a7',
indexName: 'markdownguide',
inputSelector: '#search-input',
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>

  </body>
</html>
