I"6<h2 id="сложность-алгоритма">Сложность алгоритма</h2>

<p>Математический анализ любого алгоритма всегда неразрывно связан с понятием <em>сложности</em>. Различают <em>временную</em> и <em>пространственную</em> сложности алгоритма. Понятие пространственной сложности довольно простое и практически полностью повторяет конструкцию временной, потому понятию пространственной сложности в этом разделе будет уделено мало внимания.</p>

<p>Итак, остановимся на понятии временной сложности алгоритма. Понятно, что речь идет о времени, то есть, так или иначе, о скорости работы алгоритма. В информатике важно не просто решить задачу - важно решить ее как можно более эффективно. Потому нужен <strong>формальный</strong> инструмент, при помощи которого мы могли бы сравнивать алгоритмы, решающие одну и ту же задачу, между собой и выбирать из них лучший.</p>

<p>Здесь нужно обратить внимание, что, не смотря на принципы олимпиадного программирования, идея засечь секундомером время, которое потребовалось алгоритму для решения задачи, совершенно не подходит для этих целей (и тем самым подобная характеристика не может называться временной сложностью).</p>

<div class="question">Как вы думаете, почему нельзя назвать астрономическое время работы алгоритма универсальной характеристикой, говорящей о его эффективности?</div>

<p>Рассмотрим некоторый алгоритм $\mathcal{A}$. Алгоритм всегда формулируется на языке исполнителя, то есть всегда ориентирован на некоторого исполнителя. Существуют разные теоретические исполнители: <a href="https://ru.wikipedia.org/wiki/Машина_Тьюринга">машина Тьюринга</a>, <a href="https://ru.wikipedia.org/wiki/Нормальный_алгоритм">алгоритмы Маркова</a>, <a href="https://ru.wikipedia.org/wiki/RAM-машина">RAM-машина</a>. В каждой из этих моделей подробно описывается, из чего она состоит и как происходит выполнение алгоритма, а также описывается набор так называемых <strong>элементарных действий</strong>, которые может совершать этот исполнитель (сдвинуть головку вправо, сделать запись, сделать замену подстроки, записать в определенный регистр и т.д.). Большинство себе представляют алгоритм как код на языке Python или С++, что в принципе, совершенно естественно. Элементарными тогда называют, как правило, очень простые атомарные действия: присваивание, арифметические операции, сравнения, обращение по индексу к элементу массива и др. Нужно понимать, что это некоторая вольность, которая снижает степень математической строгости, но так делать можно. (На самом деле, в случае, например, С++, код всегда переводится в процессе компиляции в язык ассемблера, система команд которого очень походит на  элементарные команды RAM-машины. То есть с некоторой точностью можно установить соответствие  между простыми командами С++, которые мы назвали элементарными, и элементарными действиями настоящей математической модели вычислений.) Сформулируем теперь простое определение.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>

  <em>Временной сложностью</em> алгоритма $\mathcal{A}$ назовем функцию $T^{\mathcal{A}}\colon \texttt{Inputs}\to \mathbb{N}$, которая каждым входным данным алгоритма сопоставляет количество элементарных действий, которые алгоритм сделает в процессе преобразования этих входных данных в результат.

   <a name="complexity"></a> 
  <br />
  
</div>

<p>Заметим, что функция очень абстрактная: она определена для любого корректного входа любой длины. Такой объект анализировать математически крайне трудно, поэтому вводят еще несколько определений.</p>

<p>Рассмотрим теперь множество потенциальных входных данных для нашего алгоритма $\texttt{Inputs}$. На этом множестве всегда можно ввести некоторую уместную числовую характеристику «длину входа» $\texttt{len}$. Например, если на вход подается одно единственное число, то можно рассмотреть количество десятичных разрядов в нем (а лучше количество двоичных), а если на вход подаются числа для обработки — рассмотреть количество этих чисел. Эта характеристика всегда выбирается отдельно для анализа каждой задачи. Таким образом, можно разбить все входы на непересекающиеся множества входов определенной длины:</p>

\[\texttt{Inputs} = \texttt{Inputs}_{\texttt{len=1}} \,\sqcup\, \texttt{Inputs}_{\texttt{len=2}} 
\,\sqcup\, \ldots
\,\sqcup\, 
\texttt{Inputs}_{\texttt{len}=n}\,\sqcup\,\ldots\]

<p>Тогда мы можем, например, составить более простые функции.</p>

<div class="alert alert-definition">
  <img class="alert-icon" src="/assets/images/icons/study.png" alt="icon" /><div class="alert-name">Определение</div>
  <em>Сложностью в худшем случае</em> алгоритма $\mathcal{A}$ назовем функцию 
  $$f(n)=\max_{\texttt{input}\in\texttt{Inputs}_{\texttt{len}=n}}{T^{\mathcal{A}}(\texttt{input})}.$$
</div>

<p>Таким образом мы получаем функцию $f(n)$ от длины входных данных. Определение совершенно естественно: для сложности в худшем случае мы зафиксируем определенную длину $n$, и рассмотрим, в каком-то смысле, «самые плохие» входные данные $\texttt{input}\in\texttt{Inputs}_{\texttt{len}=n}$  длины $n$, дающие самое большое количество элементарных действий $T^{\mathcal{A}}(\texttt{input})$.</p>

<p>Определение <em>сложности в лучшем случае</em> аналогично, только по всем входам фиксированной длины берется минимум, а не максимум. Такой вид сложности обычно представляет меньший интерес: зачем нам знать факт, что на каком-то отдельном входе алгоритм работает хорошо (при том, что, возможно, на всех остальных входах плохо).</p>

<p>Рассмотрим следующий пример кода: линейный поиск элемента $x$ в массиве $\mathbf{a}$.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>Если обозначить позицию элемента $x$ в массиве $\mathbf{a}$ (или ответ на задачу) как $k$, то можно вычислить, что мы выполняем</p>

<ul>
  <li>изначально одно присваивание <code class="language-plaintext highlighter-rouge">i=0</code>;</li>
  <li>затем $k+1$ сравнение в условии <code class="language-plaintext highlighter-rouge">for</code> и $k$ раз делаем <code class="language-plaintext highlighter-rouge">++i</code>;</li>
  <li>мы так же сделаем $k+1$ сравнений внутри <code class="language-plaintext highlighter-rouge">if</code> и $k+1$ раз обратимся по индексу <code class="language-plaintext highlighter-rouge">a[i]</code>, если элемент в массиве есть, и сделаем $k$ сравнений внутри <code class="language-plaintext highlighter-rouge">if</code> и $k$ раз обратимся по индексу <code class="language-plaintext highlighter-rouge">a[i]</code>, если элемента в массиве нет.</li>
</ul>

<p>Складываем все это и получаем, что</p>

\[T^{\mathcal{Linear Search}}(\mathbf{a}, x) = \begin{cases}
4k+4,\,\text{если элемент } x \text{ в массиве есть,}\\
4k+2,\,\text{если элемент } x \text{ в массиве отсутствует.}
\end{cases}\]

<p>Очевидно, худшими будут входные данные, при которых элемент $x$ будет отсутствовать: $k=n$. Получаем, что в худшем случае сложность алгоритма равна:</p>

\[f^{\texttt{worst}}(n) = 4n+2.\]

<p>Очевидно, в лучшем случае, когда элемент $x$ находится в самом начале, сложность получается</p>

\[f^{\texttt{best}}(n) = 4.\]

<div class="question">Какая будет временная сложность алгоритма поиска минимума в одномерном массиве длины $n$?</div>
<div class="question">Какие будут сложности в лучшем и в худшем случаях алгоритма поиска минимума в одномерном массиве длины $n$?</div>

<p>Как видно, вывести явные функции сложности в худшем случае даже для такого простого алгоритма, как линейный поиск, оказывается весьма трудоемкой задачей. Функции нередко получаются некрасивыми, громоздкими, с условиями. Более того, выписать явно функцию $T^{\mathcal{A}}$ чаще просто невозможно (это нам так повезло, что был выбран достаточно тривиальный алгоритм). К счастью, явный вид этих функций практически никогда не нужен: достаточно лишь указать оценку сверху на эти функции. Математическим способам оценки функций будет посвящен следующий раздел.</p>

<h2 id="скорости-роста-функций-и-o-символика">Скорости роста функций и O-символика</h2>
:ET